/**
 * Code Generation Tool
 *
 * Generates MCP code from the domain model at three tiers:
 * - Tier 1 (definitions): Tool/resource/prompt registration only
 * - Tier 2 (stubs): Definitions + implementation stubs with TODOs
 * - Tier 3 (full): Complete working CRUD implementation
 */

import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import type { CallToolResult, Tool } from "@modelcontextprotocol/sdk/types.js";
import { zodToJsonSchema } from "zod-to-json-schema";
import {
  type DomainModel,
  type EntityDefinition,
  type GenerateInput,
  GenerateInputSchema,
  createToolkitStorage,
} from "../model/index.js";

/**
 * Tool definition for code generation
 */
export const generateTool: Tool = {
  name: "toolkit:generate",
  description:
    "Generate MCP code from your domain model. Choose a tier: " +
    "'definitions' (registration only), 'stubs' (with TODOs), or 'full' (complete CRUD). " +
    "Use dryRun=true to preview without writing files.",
  inputSchema: zodToJsonSchema(GenerateInputSchema) as Tool["inputSchema"],
};

/**
 * Generated file content
 */
interface GeneratedFile {
  path: string;
  content: string;
  description: string;
}

/**
 * Convert PascalCase to kebab-case
 */
function toKebabCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}

/**
 * Convert PascalCase to camelCase
 */
function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

/**
 * Generate Tier 1: Tool/resource/prompt definitions only
 */
function generateTier1(
  model: DomainModel,
  entities: EntityDefinition[],
  outputDir: string
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // Generate tools index
  const toolsContent = `/**
 * Generated Tools - ${model.name}
 *
 * Tool definitions for ${model.description}
 * Generated by MCP Toolkit
 */

import type { Tool } from "@modelcontextprotocol/sdk/types.js";

${entities
  .map(
    (e) => `/**
 * Tool for managing ${e.name} entities
 */
export const ${toCamelCase(e.name)}Tool: Tool = {
  name: "${toKebabCase(model.name)}:${toKebabCase(e.name)}",
  description: "${e.description}",
  inputSchema: {
    type: "object",
    properties: {
      action: {
        type: "string",
        enum: ["create", "read", "update", "delete", "list"],
        description: "CRUD action to perform",
      },
      id: {
        type: "string",
        description: "Entity ID (required for read, update, delete)",
      },
      data: {
        type: "object",
        description: "Entity data (required for create, update)",
      },
    },
    required: ["action"],
  },
};
`
  )
  .join("\n")}

/**
 * All generated tools
 */
export const generatedTools: Tool[] = [
${entities.map((e) => `  ${toCamelCase(e.name)}Tool,`).join("\n")}
];
`;

  files.push({
    path: join(outputDir, "tools.ts"),
    content: toolsContent,
    description: "Tool definitions",
  });

  // Generate resources index
  const resourcesContent = `/**
 * Generated Resources - ${model.name}
 *
 * Resource definitions for ${model.description}
 * Generated by MCP Toolkit
 */

import type { Resource, ResourceTemplate } from "@modelcontextprotocol/sdk/types.js";

${entities
  .map(
    (e) => `/**
 * Resource template for ${e.name} entities
 */
export const ${toCamelCase(e.name)}Template: ResourceTemplate = {
  uriTemplate: "${toKebabCase(model.name)}://${toKebabCase(e.name)}/{id}",
  name: "${e.name}",
  description: "${e.description}",
  mimeType: "application/json",
};
`
  )
  .join("\n")}

/**
 * All generated resource templates
 */
export const generatedTemplates: ResourceTemplate[] = [
${entities.map((e) => `  ${toCamelCase(e.name)}Template,`).join("\n")}
];
`;

  files.push({
    path: join(outputDir, "resources.ts"),
    content: resourcesContent,
    description: "Resource definitions",
  });

  return files;
}

/**
 * Generate Tier 2: Definitions + implementation stubs
 */
function generateTier2(
  model: DomainModel,
  entities: EntityDefinition[],
  outputDir: string
): GeneratedFile[] {
  const files = generateTier1(model, entities, outputDir);

  // Add handler stubs
  for (const entity of entities) {
    const handlerContent = `/**
 * ${entity.name} Handler
 *
 * Implementation stub for ${entity.description}
 * Generated by MCP Toolkit - Tier 2
 */

import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

/**
 * ${entity.name} entity type
 */
export interface ${entity.name} {
${entity.properties.map((p) => `  ${p.name}${p.required ? "" : "?"}: ${mapTypeToTS(p.type)};`).join("\n")}
}

/**
 * Handle ${entity.name} tool calls
 */
export async function handle${entity.name}(
  action: string,
  id: string | undefined,
  data: Partial<${entity.name}> | undefined
): Promise<CallToolResult> {
  switch (action) {
    case "create":
      // TODO: Implement create logic
      // 1. Validate data
      // 2. Generate ID
      // 3. Save to storage
      return {
        content: [{ type: "text", text: "TODO: Implement create" }],
      };

    case "read":
      // TODO: Implement read logic
      // 1. Validate id exists
      // 2. Load from storage
      // 3. Return entity
      return {
        content: [{ type: "text", text: "TODO: Implement read" }],
      };

    case "update":
      // TODO: Implement update logic
      // 1. Validate id exists
      // 2. Validate data
      // 3. Update in storage
      return {
        content: [{ type: "text", text: "TODO: Implement update" }],
      };

    case "delete":
      // TODO: Implement delete logic
      // 1. Validate id exists
      // 2. Delete from storage
      return {
        content: [{ type: "text", text: "TODO: Implement delete" }],
      };

    case "list":
      // TODO: Implement list logic
      // 1. Load all from storage
      // 2. Apply filters if provided
      // 3. Return array
      return {
        content: [{ type: "text", text: "TODO: Implement list" }],
      };

    default:
      return {
        content: [{ type: "text", text: \`Unknown action: \${action}\` }],
        isError: true,
      };
  }
}
`;

    files.push({
      path: join(outputDir, "handlers", `${toKebabCase(entity.name)}.ts`),
      content: handlerContent,
      description: `${entity.name} handler stub`,
    });
  }

  return files;
}

/**
 * Generate Tier 3: Full working implementation
 */
function generateTier3(
  model: DomainModel,
  entities: EntityDefinition[],
  outputDir: string
): GeneratedFile[] {
  const files = generateTier1(model, entities, outputDir);

  // Add full implementations
  for (const entity of entities) {
    const implContent = `/**
 * ${entity.name} Implementation
 *
 * Full CRUD implementation for ${entity.description}
 * Generated by MCP Toolkit - Tier 3
 */

import { randomUUID } from "node:crypto";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

/**
 * ${entity.name} entity type
 */
export interface ${entity.name} {
  id: string;
${entity.properties.map((p) => `  ${p.name}${p.required ? "" : "?"}: ${mapTypeToTS(p.type)};`).join("\n")}
  createdAt: string;
  updatedAt: string;
}

/**
 * Storage path for ${entity.name} entities
 */
const STORAGE_DIR = "./${toKebabCase(model.name)}-data";
const STORAGE_FILE = join(STORAGE_DIR, "${toKebabCase(entity.name)}.json");

/**
 * Load all ${entity.name} entities
 */
function loadAll(): ${entity.name}[] {
  if (!existsSync(STORAGE_FILE)) {
    return [];
  }
  try {
    return JSON.parse(readFileSync(STORAGE_FILE, "utf-8"));
  } catch {
    return [];
  }
}

/**
 * Save all ${entity.name} entities
 */
function saveAll(entities: ${entity.name}[]): void {
  if (!existsSync(STORAGE_DIR)) {
    mkdirSync(STORAGE_DIR, { recursive: true });
  }
  writeFileSync(STORAGE_FILE, JSON.stringify(entities, null, 2));
}

/**
 * Handle ${entity.name} tool calls
 */
export async function handle${entity.name}(
  action: string,
  id: string | undefined,
  data: Partial<${entity.name}> | undefined
): Promise<CallToolResult> {
  const entities = loadAll();

  switch (action) {
    case "create": {
      if (!data) {
        return {
          content: [{ type: "text", text: "Data is required for create" }],
          isError: true,
        };
      }

      const now = new Date().toISOString();
      const newEntity: ${entity.name} = {
        id: randomUUID(),
        ...data as Omit<${entity.name}, "id" | "createdAt" | "updatedAt">,
        createdAt: now,
        updatedAt: now,
      };

      entities.push(newEntity);
      saveAll(entities);

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(newEntity, null, 2),
          },
        ],
      };
    }

    case "read": {
      if (!id) {
        return {
          content: [{ type: "text", text: "ID is required for read" }],
          isError: true,
        };
      }

      const entity = entities.find((e) => e.id === id);
      if (!entity) {
        return {
          content: [{ type: "text", text: \`${entity.name} not found: \${id}\` }],
          isError: true,
        };
      }

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(entity, null, 2),
          },
        ],
      };
    }

    case "update": {
      if (!id) {
        return {
          content: [{ type: "text", text: "ID is required for update" }],
          isError: true,
        };
      }

      const index = entities.findIndex((e) => e.id === id);
      if (index === -1) {
        return {
          content: [{ type: "text", text: \`${entity.name} not found: \${id}\` }],
          isError: true,
        };
      }

      entities[index] = {
        ...entities[index],
        ...data,
        id, // Preserve ID
        createdAt: entities[index].createdAt, // Preserve createdAt
        updatedAt: new Date().toISOString(),
      };
      saveAll(entities);

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(entities[index], null, 2),
          },
        ],
      };
    }

    case "delete": {
      if (!id) {
        return {
          content: [{ type: "text", text: "ID is required for delete" }],
          isError: true,
        };
      }

      const deleteIndex = entities.findIndex((e) => e.id === id);
      if (deleteIndex === -1) {
        return {
          content: [{ type: "text", text: \`${entity.name} not found: \${id}\` }],
          isError: true,
        };
      }

      const deleted = entities.splice(deleteIndex, 1)[0];
      saveAll(entities);

      return {
        content: [
          {
            type: "text",
            text: \`Deleted ${entity.name}: \${deleted.id}\`,
          },
        ],
      };
    }

    case "list": {
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(entities, null, 2),
          },
        ],
      };
    }

    default:
      return {
        content: [{ type: "text", text: \`Unknown action: \${action}\` }],
        isError: true,
      };
  }
}
`;

    files.push({
      path: join(outputDir, "handlers", `${toKebabCase(entity.name)}.ts`),
      content: implContent,
      description: `${entity.name} full implementation`,
    });
  }

  // Add handlers index
  const handlersIndexContent = `/**
 * Generated Handlers Index
 *
 * Re-exports all entity handlers
 */

${entities.map((e) => `export * from "./${toKebabCase(e.name)}.js";`).join("\n")}
`;

  files.push({
    path: join(outputDir, "handlers", "index.ts"),
    content: handlersIndexContent,
    description: "Handlers index",
  });

  return files;
}

/**
 * Map our types to TypeScript types
 */
function mapTypeToTS(type: string): string {
  switch (type) {
    case "string":
    case "uuid":
    case "email":
    case "url":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "date":
    case "datetime":
      return "string"; // ISO date string
    case "array":
      return "unknown[]";
    case "object":
    case "json":
      return "Record<string, unknown>";
    default:
      return "unknown";
  }
}

/**
 * Handle generate tool call
 */
export async function handleGenerate(args: unknown, _context: unknown): Promise<CallToolResult> {
  // Validate input
  const parseResult = GenerateInputSchema.safeParse(args);
  if (!parseResult.success) {
    return {
      content: [
        {
          type: "text",
          text: `Invalid input: ${parseResult.error.message}`,
        },
      ],
      isError: true,
    };
  }

  const input = parseResult.data as GenerateInput;
  const storage = createToolkitStorage();

  // Load model
  const modelResult = storage.loadModel();
  if (!modelResult.success || !modelResult.data) {
    return {
      content: [
        {
          type: "text",
          text: "No model found. Use 'toolkit:model:design' to create one first.",
        },
      ],
      isError: true,
    };
  }

  const model = modelResult.data;
  const outputDir = input.outputDir || join(storage.getBaseDir(), "src", "generated");

  // Filter entities if specified
  let entities = model.entities;
  if (input.entities && input.entities.length > 0) {
    entities = entities.filter((e) => input.entities!.includes(e.name));
    if (entities.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: `No matching entities found. Available: ${model.entities.map((e) => e.name).join(", ")}`,
          },
        ],
        isError: true,
      };
    }
  }

  // Generate files based on tier
  let files: GeneratedFile[];
  switch (input.tier) {
    case "definitions":
      files = generateTier1(model, entities, outputDir);
      break;
    case "stubs":
      files = generateTier2(model, entities, outputDir);
      break;
    case "full":
      files = generateTier3(model, entities, outputDir);
      break;
    default:
      return {
        content: [
          {
            type: "text",
            text: `Unknown tier: ${input.tier}`,
          },
        ],
        isError: true,
      };
  }

  // Dry run - just show what would be generated
  if (input.dryRun) {
    const preview = files
      .map(
        (f) =>
          `**${f.path}** - ${f.description}\n\`\`\`typescript\n${f.content.slice(0, 500)}${f.content.length > 500 ? "\n// ... (truncated)" : ""}\n\`\`\``
      )
      .join("\n\n");

    return {
      content: [
        {
          type: "text",
          text: [
            "**Dry Run - Files that would be generated:**",
            "",
            preview,
            "",
            `Total: ${files.length} files`,
            "",
            "Run without dryRun=true to write files.",
          ].join("\n"),
        },
      ],
    };
  }

  // Write files
  const writtenFiles: string[] = [];
  const errors: string[] = [];

  for (const file of files) {
    try {
      const dir = dirname(file.path);
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
      writeFileSync(file.path, file.content);
      writtenFiles.push(file.path);
    } catch (error) {
      errors.push(`${file.path}: ${error}`);
    }
  }

  // Update state
  storage.updateState({
    phase: "setup",
    generationTier: input.tier,
    generatedFiles: writtenFiles,
  });

  const summary = [
    `**Generation Complete - Tier: ${input.tier}**`,
    "",
    `Generated ${writtenFiles.length} files for ${entities.length} entities:`,
    ...writtenFiles.map((f) => `- ${f}`),
    errors.length > 0 ? `\n**Errors:** ${errors.length}` : null,
    errors.length > 0 ? errors.join("\n") : null,
    "",
    "Next steps:",
    "1. Review the generated code",
    "2. Customize implementations as needed",
    "3. Use 'toolkit:setup:client' to configure your IDE",
  ]
    .filter(Boolean)
    .join("\n");

  return {
    content: [
      {
        type: "text",
        text: summary,
      },
    ],
  };
}
